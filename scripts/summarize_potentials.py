"""Generates .nc and .csv files (longform data) that summarize the potentials (= per-tech constriants) for each
technology and each location."""

import calliope
import numpy as np
import xarray as xr


def summarize_potentials(
    path_to_model: str, path_to_output_csv: str, path_to_output_netcdf: str, sf: dict
) -> None:

    """
    Generates .nc and .csv files (longform data) that summarize the potentials (= per-tech constriants) for each
    technology and each location.

    CAVEAT: Techs that are defined but do not appear at at least one location
    (including all transmission technologies) do not show up in get_formatted_array and are thus not reported in the
    csv/nc files generated by this script. If techs are allocated to locations, but their potential is not overriden
    for specific locations, the globally defined potential is used for each location. If no globally defined
    potential exists, NaN is used. In the .csv file, NaNs are dropped.

    Args:
        path_to_model (str):
            Location of model file (example-model.yaml) for each resolution
        path_to_output_csv (str):
            Location to store generated csv file with summary of potentials
        path_to_output_netcdf (str):
            Location to store generated netcdf file with summary of potentials
        sf (dict):
            Dictionary of scaling factors for power, area, monetary as defined in config file
    """

    considered_potentials = {"energy_cap_max": {"sf": sf["power"], "unit": "MW"},
                             "energy_cap_equals": {"sf": sf["power"], "unit": "MW"},
                             "storage_cap_max": {"sf": sf["power"], "unit": "MWh"},
                             "storage_cap_equals": {"sf": sf["power"], "unit": "MWh"}
                             }
    # Can be extended with other per-tech constraint variables of the model (pay attention to units/scaling factors).

    model = calliope.Model(path_to_model)

    list_of_techs = model.inputs.techs.values
    list_of_locs = model.inputs.locs.values
    list_of_potentials = list(considered_potentials.keys())

    summary = np.empty((len(list_of_techs), len(list_of_potentials), len(list_of_locs)))
    summary[:] = np.nan
    units = np.empty((len(list_of_techs), len(list_of_potentials), len(list_of_locs)), dtype='<U32')
    units[:] = np.nan

    summary = xr.DataArray(summary,
                           dims=("techs", "potentials", "locs"),
                           coords={"techs": list_of_techs,
                                   "potentials": list_of_potentials,
                                   "locs": list_of_locs,
                                   "unit": (["techs", "potentials", "locs"], units)}
                           )

    for potential in list_of_potentials:
        aux = model.get_formatted_array(potential)
        for tech in list_of_techs:
            for loc in list_of_locs:
                try:
                    summary.loc[dict(techs=tech, locs=loc, potentials=potential)] = aux.loc[
                        dict(techs=tech, locs=loc)] / considered_potentials[potential]["sf"]
                    summary.coords["unit"].loc[
                        dict(techs=tech, locs=loc, potentials=potential)] = considered_potentials[potential]["unit"]
                except KeyError:
                    # If a technology "tech" is not installed in location "loc", or the potential "potential"
                    # is not defined for "tech" at "loc", value and unit remain "NaN".
                    continue

    summary.to_netcdf(path_to_output_netcdf)
    summary.to_dataframe(name="value").dropna(axis="index", how="any").to_csv(path_to_output_csv)


if __name__ == "__main__":
    summarize_potentials(
        path_to_model=snakemake.input.path_to_model,
        path_to_output_csv=snakemake.output.csv,
        path_to_output_netcdf=snakemake.output.netcdf,
        sf=snakemake.params.scaling_factors
    )
